% Copyright 2017-2020 Carnegie Mellon University.
% ============================================================================================
% Driver rules for forward reasoning
% ============================================================================================

% These rules turn ordinary forward reasoning rules into dynamically asserted facts.  They
% follow a fairly rigid pattern, and might be generated by Prolog meta-programming in the
% future to keep the code cleaner.  These rules have been moved out of rules.pl to make space
% for more important rules that aren't just machinery...

% Each rule takes no parameters because it is supposed to assert a single fact in the same way
% that the guessing rules currently do, and return the callable parameter in "Out".

% The standard form of these rules (with commentary) is:
%
%concludeXXX(Out) :-
%    % We begin with an unbound set of parameters to a reasoning method.  In general, leaving the
%    % parameters unbound, and letting Prolog do it's thing has performed better than trying to
%    % enumerate possible values before calling reasonXXX().  It's a little unclear why, but
%    % that's what Cory's observed.
%    reasonXXX(Parameters),
%
%    % Occasionally there will be additional _fast_ constraints here.  iso_dif in particular
%    may be faster than a table lookup, since it's mostly a built in.
%    iso_dif(Parameter1, Parameter2),
%
%    % Check that the fact hasn't already been asserted.
%    not(factXXX(Parameters)),
%
%    % Check that there's no contradictory reasoning (not always required).
%    not(factNOTXXX(Parameters)),
%
%    % Although we're not doing so right now, it might be beneficial to have certain
%    % constraints that are always required here instead of in each reasoning rule?
%
%    % Report what we're doing for debugging.
%    loginfoln('Concluding ~Q.', factXXX(Parameters)),
%
%    % Then return the assertion in the Out Parameters, so that the caller can call() it to
%    % assert the fact.  Asserting the fact in our caller allows us to backtrack properly, while
%    % making the assertion here directly did not. Also the concludeMergeClasses() rule is a
%    % special case in that it does more than just call try_assert().
%    Out = try_assert(factXXX(Parameters)).

:- use_module(library(apply), [maplist/2, maplist/3]).

:- dynamic forward_pending/1.

% --------------------------------------------------------------------------------------------
% Make a singleton class for any method in Set.
makeObjects(Set) :-
    maplist(make, Set).

% This predicate is called to retract subsumed facts
class_size_remove_redundant(factClassSizeGTE(Class, Size)) :-
    !,
    (setof(factClassSizeGTE(Class, TSize),
           (factClassSizeGTE(Class, TSize),
            TSize < Size),
           SizeFactSet) ->
         maplist(try_retract, SizeFactSet);
     true).

class_size_remove_redundant(factClassSizeLTE(Class, Size)) :-
    !,
    (setof(factClassSizeLTE(Class, TSize),
          (factClassSizeLTE(Class, TSize),
           TSize > Size),
          SizeFactSet) ->
     maplist(try_retract, SizeFactSet);
    true).

class_size_remove_redundant(X) :-
    throw_with_backtrace(error(representation_error(X), class_size_remove_redundant/1)).
ignore_one_arg(_X).

% Helper that produces an action from the arguments
try_assert_builder(Pred, ArgTuple, Out) :-
    try_assert_builder(ignore_one_arg, Pred, ArgTuple, Out).

try_assert_builder(Extra, Pred, ArgTuple, Out) :-
    tuple_to_list(ArgTuple, TupleElements),
    Fact =.. [Pred|TupleElements],
    Out = (try_assert(Fact),
           call(Extra, Fact)).

:- meta_predicate make_wrapper(0).
:- table make_wrapper/1 as incremental.
make_wrapper(Goal) :-
    forall(call(Goal),
           (logtraceln('Queueing ~Q.', Goal),
            assert(forward_pending(Goal)))).

concludeMethod(Out) :-
    reportFirstSeen('concludeMethod'),
    make_wrapper(reasonMethod(Method)),
    setof(Method,
          (retract(forward_pending(reasonMethod(Method))),
           not(factMethod(Method)),
           not(factNOTMethod(Method)),
           loginfoln('Concluding ~Q.', factMethod(Method))),
          MethodSets),
    maplist(try_assert_builder(factMethod), MethodSets, ActionSets),
    % Note: After we create the factMethod facts, we call makeNewObjects to ensure the proper
    % classes are created.
    Out = ((all(ActionSets),
            makeObjects(MethodSets))).

concludeConstructor(Out) :-
    reportFirstSeen('concludeConstructor'),
    make_wrapper(reasonConstructor(Method)),
    setof(Method,
          (retract(forward_pending(reasonConstructor(Method))),
           not(factConstructor(Method)),
           not(factNOTConstructor(Method)),
           loginfoln('Concluding ~Q.', factConstructor(Method))),
          MethodSets),
    maplist(try_assert_builder(factConstructor), MethodSets, ActionSets),
    Out = all(ActionSets).

concludeNOTConstructor(Out) :-
    reportFirstSeen('concludeNOTConstructor'),
    make_wrapper(reasonNOTConstructor(Method)),
    setof(Method,
          (retract(forward_pending(reasonNOTConstructor(Method))),
           not(factNOTConstructor(Method)),
           not(factConstructor(Method)),
           loginfoln('Concluding ~Q.', factNOTConstructor(Method))),
          MethodSets),
    maplist(try_assert_builder(factNOTConstructor), MethodSets, ActionSets),
    Out = all(ActionSets).

concludeRealDestructor(Out) :-
    reportFirstSeen('concludeRealDestructor'),
    make_wrapper(reasonRealDestructor(Method)),
    setof(Method,
          (retract(forward_pending(reasonRealDestructor(Method))),
           not(factRealDestructor(Method)),
           not(factNOTRealDestructor(Method)),
           loginfoln('Concluding ~Q.', factRealDestructor(Method))),
          MethodSets),
    maplist(try_assert_builder(factRealDestructor), MethodSets, ActionSets),
    Out = all(ActionSets).

concludeNOTRealDestructor(Out) :-
    reportFirstSeen('concludeNOTRealDestructor'),
    make_wrapper(reasonNOTRealDestructor(Method)),
    setof(Method,
          (retract(forward_pending(reasonNOTRealDestructor(Method))),
           not(factRealDestructor(Method)),
           not(factNOTRealDestructor(Method)),
           loginfoln('Concluding ~Q.', factNOTRealDestructor(Method))),
          MethodSets),
    maplist(try_assert_builder(factNOTRealDestructor), MethodSets, ActionSets),
    Out = all(ActionSets).

concludeDeletingDestructor(Out) :-
    reportFirstSeen('concludeDeletingDestructor'),
    make_wrapper(reasonDeletingDestructor(Method)),
    setof(Method,
          (retract(forward_pending(reasonDeletingDestructor(Method))),
           not(factDeletingDestructor(Method)),
           not(factNOTDeletingDestructor(Method)),
           loginfoln('Concluding ~Q.', factDeletingDestructor(Method))),
          MethodSets),
    maplist(try_assert_builder(factDeletingDestructor), MethodSets, ActionSets),
    Out = all(ActionSets).

concludeNOTDeletingDestructor(Out) :-
    reportFirstSeen('concludeNOTDeletingDestructor'),
    break,
    make_wrapper(reasonNOTDeletingDestructor(Method)),
    setof(Method,
          (retract(forward_pending(reasonNOTDeletingDestructor(Method))),
           not(factDeletingDestructor(Method)),
           not(factNOTDeletingDestructor(Method)),
           loginfoln('Concluding ~Q.', factNOTDeletingDestructor(Method))),
          MethodSets),
    maplist(try_assert_builder(factNOTDeletingDestructor), MethodSets, ActionSets),
    Out = all(ActionSets).

% This fact is only reasoned about, and it's similar to derived constructor.
concludeObjectInObject(Out) :-
    reportFirstSeen('concludeObjectInObject'),
    make_wrapper(reasonObjectInObject(OuterClass, InnerClass, Offset)),
    setof((OuterClass, InnerClass, Offset),
          (retract(forward_pending(reasonObjectInObject(OuterClass, InnerClass, Offset))),
           is_current(OuterClass),
           is_current(InnerClass),
           iso_dif(OuterClass, InnerClass),
           not(factObjectInObject(OuterClass, InnerClass, Offset)),
           % There's no factNOTObjectInObject, since most things aren't in most other things.
           loginfoln('Concluding ~Q.', factObjectInObject(OuterClass, InnerClass, Offset))),
          TupleSets),
    maplist(try_assert_builder(factObjectInObject), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeDerivedClass(Out) :-
    reportFirstSeen('concludeDerivedClass'),
    make_wrapper(reasonDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
    setof((DerivedClass, BaseClass, ObjectOffset),
          (retract(forward_pending(reasonDerivedClass(DerivedClass, BaseClass, ObjectOffset))),
           is_current(DerivedClass),
           is_current(BaseClass),
           iso_dif(DerivedClass, BaseClass),
           not(factDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
           not(factNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
           loginfoln('Concluding ~Q.',
                     factDerivedClass(DerivedClass, BaseClass, ObjectOffset))),
          TupleSets),
    maplist(try_assert_builder(factDerivedClass), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeNOTDerivedClass(Out) :-
    reportFirstSeen('concludeNOTDerivedClass'),
    make_wrapper(reasonNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
    setof((DerivedClass, BaseClass, ObjectOffset),
          (retract(forward_pending(reasonNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset))),
           is_current(DerivedClass),
           is_current(BaseClass),
           iso_dif(DerivedClass, BaseClass),
           not(factDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
           not(factNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
           loginfoln('Concluding ~Q.',
                     factNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset))),
          TupleSets),
    maplist(try_assert_builder(factNOTDerivedClass), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeEmbeddedObject(Out) :-
    reportFirstSeen('concludeEmbeddedObject'),
    make_wrapper(reasonEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
    setof((OuterClass, InnerClass, ObjectOffset),
          (retract(forward_pending(reasonEmbeddedObject(OuterClass, InnerClass, ObjectOffset))),
           is_current(OuterClass),
           is_current(InnerClass),
           iso_dif(OuterClass, InnerClass),
           not(factEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
           not(factNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
           loginfoln('Concluding ~Q.',
                     factEmbeddedObject(OuterClass, InnerClass, ObjectOffset))),
          TupleSets),
    maplist(try_assert_builder(factEmbeddedObject), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeNOTEmbeddedObject(Out) :-
    reportFirstSeen('concludeNOTEmbeddedObject'),
    make_wrapper(reasonNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
    setof((OuterClass, InnerClass, ObjectOffset),
          (retract(forward_pending(reasonNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset))),
           is_current(OuterClass),
           is_current(InnerClass),
           iso_dif(OuterClass, InnerClass),
           not(factEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
           not(factNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
           loginfoln('Concluding ~Q.',
                     factNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset))),
          TupleSets),
    maplist(try_assert_builder(factNOTEmbeddedObject), TupleSets, ActionSets),
    Out = all(ActionSets).

% --------------------------------------------------------------------------------------------

concludeVFTable(Out) :-
    reportFirstSeen('concludeVFTable'),
    make_wrapper(reasonVFTable(VFTable)),
    setof(VFTable,
          (retract(forward_pending(reasonVFTable(VFTable))),
           not(factVFTable(VFTable)),
           not(factNOTVFTable(VFTable)),
           loginfoln('Concluding ~Q.', factVFTable(VFTable))),
          VFTableSets),
    maplist(try_assert_builder(factVFTable), VFTableSets, ActionSets),
    Out = ((all(ActionSets),
            makeObjects(VFTableSets))).

% There's no reasoning for NOT a vftable?  The fact might be asserted by a failed guess, but
% that's about as close as we would get to reasoning currently...

concludeVFTableWrite(Out) :-
    reportFirstSeen('concludeVFTableWrite'),
    make_wrapper(reasonVFTableWrite(Insn, Method, Offset, VFTable)),
    setof((Insn, Method, Offset, VFTable),
          (retract(forward_pending(reasonVFTableWrite(Insn, Method, Offset, VFTable))),
           not(factVFTableWrite(Insn, Method, Offset, VFTable)),
           %not(reasonNOTVFTableWrite(Insn, Method, Offset, VFTable)),
           loginfoln('Concluding ~Q.', factVFTableWrite(Insn, Method, Offset, VFTable))),
          TupleSets),
    maplist(try_assert_builder(factVFTableWrite), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeVFTableOverwrite(Out) :-
    reportFirstSeen('concludeVFTableOverwrite'),
    make_wrapper(reasonVFTableOverwrite(Method, VFTable1, VFTable2, Offset)),
    setof((Method, VFTable1, VFTable2, Offset),
          (retract(forward_pending(reasonVFTableOverwrite(Method, VFTable1, VFTable2, Offset))),
           not(factVFTableOverwrite(Method, VFTable1, VFTable2, Offset)),
           %not(reasonNOTVFTableOverwrite(Method, VFTable1, VFTable2, Offset)),
           loginfoln('Concluding ~Q.',
                     factVFTableOverwrite(Method, VFTable1, VFTable2, Offset))),
          TupleSets),
    maplist(try_assert_builder(factVFTableOverwrite), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeVFTableEntry(Out) :-
    reportFirstSeen('concludeVFTableEntry'),
    make_wrapper(reasonVFTableEntry(VFTable, VFTableOffset, Address)),
    setof((VFTable, VFTableOffset, Address),
          (retract(forward_pending(reasonVFTableEntry(VFTable, VFTableOffset, Address))),
           not(factVFTableEntry(VFTable, VFTableOffset, Address)),
           not(factNOTVFTableEntry(VFTable, VFTableOffset, Address)),
           loginfoln('Concluding ~Q.',
                     factVFTableEntry(VFTable, VFTableOffset, Address))),
          TupleSets),
    maplist(try_assert_builder(factVFTableEntry), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeNOTVFTableEntry(Out) :-
    reportFirstSeen('concludeNOTVFTableEntry'),
    make_wrapper(reasonNOTVFTableEntry(VFTable, VFTableOffset, Address)),
    setof((VFTable, VFTableOffset, Address),
          (retract(forward_pending(reasonNOTVFTableEntry(VFTable, VFTableOffset, Address))),
           not(factVFTableEntry(VFTable, VFTableOffset, Address)),
           not(factNOTVFTableEntry(VFTable, VFTableOffset, Address)),
           loginfoln('Concluding ~Q.',
                     factNOTVFTableEntry(VFTable, VFTableOffset, Address))),
          TupleSets),
    maplist(try_assert_builder(factNOTVFTableEntry), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeVFTableSizeGTE(Out) :-
    reportFirstSeen('concludeVFTableSizeGTE'),
    make_wrapper(reasonVFTableSizeGTE(VFTable, Size)),
    setof((VFTable, Size),
          (retract(forward_pending(reasonVFTableSizeGTE(VFTable, Size))),
           not((factVFTableSizeGTE(VFTable, KnownSize), KnownSize >= Size)),
           loginfoln('Concluding ~Q.',
                     factVFTableSizeGTE(VFTable, Size))),
          TupleSets),
    maplist(try_assert_builder(factVFTableSizeGTE), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeVFTableSizeLTE(Out) :-
    reportFirstSeen('concludeVFTableSizeLTE'),
    make_wrapper(reasonVFTableSizeLTE(VFTable, Size)),
    setof((VFTable, Size),
          (retract(forward_pending(reasonVFTableSizeLTE(VFTable, Size))),
           not((factVFTableSizeLTE(VFTable, KnownSize), KnownSize >= Size)),
           loginfoln('Concluding ~Q.',
                     factVFTableSizeLTE(VFTable, Size))),
          TupleSets),
    maplist(try_assert_builder(factVFTableSizeLTE), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeVirtualFunctionCall(Out) :-
    reportFirstSeen('concludeVirtualFunctionCall'),
    make_wrapper(reasonVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset)),
    setof((Insn, Method, OOffset, VFTable, TOffset),
          (retract(forward_pending(reasonVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset))),
           not(factVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset)),
           not(factNOTVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset)),
           loginfoln('Concluding ~Q.',
                     factVirtualFunctonCall(Insn, Method, OOffset, VFTable, TOffset))),
          TupleSets),
    maplist(try_assert_builder(factVirtualFunctionCall), TupleSets, ActionSets),
    Out = all(ActionSets).

% --------------------------------------------------------------------------------------------

concludeVBTable(Out) :-
    reportFirstSeen('concludeVBTable'),
    make_wrapper(reasonVBTable(VBTable)),
    setof(VBTable,
          (retract(forward_pending(reasonVBTable(VBTable))),
           not(factVBTable(VBTable)),
           not(factNOTVBTable(VBTable)),
           loginfoln('Concluding ~Q.', factVBTable(VBTable))),
          VBTableSets),
    maplist(try_assert_builder(factVBTable), VBTableSets, ActionSets),
    Out = all(ActionSets).

% There are currently no forward reasoning rules for factNOTVBTable.

concludeVBTableWrite(Out) :-
    reportFirstSeen('concludeVBTableWrite'),
    make_wrapper(reasonVBTableWrite(Insn, Method, Offset, VBTable)),
    setof((Insn, Method, Offset, VBTable),
          (retract(forward_pending(reasonVBTableWrite(Insn, Method, Offset, VBTable))),
           not(factVBTableWrite(Insn, Method, Offset, VBTable)),
           %not(reasonNOTVBTableWrite(Insn, Method, Offset, VBTable)),
           loginfoln('Concluding ~Q.',
                     factVBTableWrite(Insn, Method, Offset, VBTable))),
          TupleSets),
    maplist(try_assert_builder(factVBTableWrite), TupleSets, ActionSets),
    Out = all(ActionSets).

% There are currently no forward reasoning rules for factNOTVBTableWrite.

concludeVBTableEntry(Out) :-
    reportFirstSeen('concludeVBTableEntry'),
    make_wrapper(reasonVBTableEntry(VBTable, VBTableOffset, Value)),
    setof((VBTable, VBTableOffset, Value),
          (retract(forward_pending(reasonVBTableEntry(VBTable, VBTableOffset, Value))),
           not(factVBTableEntry(VBTable, VBTableOffset, Value)),
           not(factNOTVBTableEntry(VBTable, VBTableOffset, Value)),
           loginfoln('Concluding ~Q.',
                     factVBTableEntry(VBTable, VBTableOffset, Value))),
          TupleSets),
    maplist(try_assert_builder(factVBTableEntry), TupleSets, ActionSets),
    Out = all(ActionSets).

% There are currently no forward reasoning rules for factNOTVBTableEntry.

% --------------------------------------------------------------------------------------------

% XXX Can we generalize the _wrapper funcs?  Should be able to.


concludeClassSizeGTE(Out) :-
    reportFirstSeen('concludeClassSizeGTE'),
    make_wrapper(reasonClassSizeGTE(Class, Size)),
    setof((Class, Size),
          (retract(forward_pending(reasonClassSizeGTE(Class, Size))),
           is_current(Class),
           not((factClassSizeGTE(Class, KnownSize), KnownSize >= Size)),
           loginfoln('Concluding ~Q.',
                     factClassSizeGTE(Class, Size))),
          TupleSets),
    maplist(try_assert_builder(class_size_remove_redundant, factClassSizeGTE), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeClassSizeLTE(Out) :-
    reportFirstSeen('concludeClassSizeLTE'),
    make_wrapper(reasonClassSizeLTE(Class, Size)),
    setof((Class, Size),
          (retract(forward_pending(reasonClassSizeLTE(Class, Size))),
           is_current(Class),
           not((factClassSizeLTE(Class, KnownSize), KnownSize =< Size)),
           loginfoln('Concluding ~Q.',
                     factClassSizeLTE(Class, Size))),
          TupleSets),
    maplist(try_assert_builder(class_size_remove_redundant, factClassSizeLTE), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeClassHasNoBase(Out) :-
    reportFirstSeen('concludeClassHasNoBase'),
    make_wrapper(reasonClassHasNoBase(Class)),
    setof(Class,
          (retract(forward_pending(reasonClassHasNoBase(Class))),
           is_current(Class),
           not(factClassHasNoBase(Class)),
           not(factClassHasUnknownBase(Class)),
           loginfoln('Concluding ~Q.', factClassHasNoBase(Class))),
          ClassSets),
    maplist(try_assert_builder(factClassHasNoBase), ClassSets, ActionSets),
    Out = all(ActionSets).

concludeClassHasUnknownBase(Out) :-
    reportFirstSeen('concludeClassHasUnknownBase'),
    make_wrapper(reasonClassHasUnknownBase(Class)),
    setof(Class,
          (retract(forward_pending(reasonClassHasUnknownBase(Class))),
           is_current(Class),
           not(factClassHasUnknownBase(Class)),
           not(factClassHasNoBase(Class)),
           loginfoln('Concluding ~Q.', factClassHasUnknownBase(Class))),
          ClassSets),
    maplist(try_assert_builder(factClassHasUnknownBase), ClassSets, ActionSets),
    Out = all(ActionSets).

concludeReusedImplementation(Out) :-
    reportFirstSeen('concludeReusedImplementation'),
    make_wrapper(reasonReusedImplementation(Method)),
    setof(Method,
          (retract(forward_pending(reasonReusedImplementation(Method))),
           not(factReusedImplementation(Method)),
           loginfoln('Concluding ~Q.', factReusedImplementation(Method))),
          MethodSets),
    maplist(try_assert_builder(factReusedImplementation), MethodSets, ActionSets),
    Out = all(ActionSets).

concludeClassCallsMethod(Out) :-
    reportFirstSeen('concludeClassCallsMethod'),
    make_wrapper(reasonClassCallsMethod(Class, Method)),
    setof((Class, Method),
          ExistingClass^(retract(forward_pending(reasonClassCallsMethod(Class, Method))),
           iso_dif(Class, Method),
           find_current(Method, ExistingClass),
           iso_dif(Class, ExistingClass),
           not(factClassCallsMethod(Class, Method)),
           %not(factNOTClassCallsMethod(Class, Method)),
           loginfoln('Concluding ~Q.',
                     factClassCallsMethod(Class, Method))),
          TupleSets),
    maplist(try_assert_builder(factClassCallsMethod), TupleSets, ActionSets),
    Out = all(ActionSets).

concludeNOTMergeClasses(Out) :-
    reportFirstSeen('concludeNOTMergeClasses'),
    make_wrapper(reasonNOTMergeClasses_new(Class1, Class2)),
    setof((Class1, Class2),
          (retract(forward_pending(reasonNOTMergeClasses_new(Class1, Class2))),
           logtraceln('Considering ~Q.', reasonNOTMergeClasses_new(Class1, Class2)),
           is_current(Class1),
           is_current(Class2),
           iso_dif(Class1, Class2),
           not(dynFactNOTMergeClasses(Class1, Class2)),
           loginfoln('Concluding ~Q.',
                     factNOTMergeClasses(Class1, Class2))),
          ClassSets),
    maplist(try_assert_builder(factNOTMergeClasses), ClassSets, ActionSets),
    Out = all(ActionSets).

concludeMergeVFTables(Out) :-
    reportFirstSeen('concludeMergeVFTables'),
    reasonMergeVFTables(Class1, Class2),
    is_current(Class1),
    is_current(Class2),
    not(dynFactNOTMergeClasses(Class1, Class2)),
    loginfoln('Concluding ~Q.', mergeVFTables(Class1, Class2)),
    Out = mergeClasses(Class1, Class2).

concludeMergeClasses(Out) :-
    reportFirstSeen('concludeMergeClasses'),
    reasonMergeClasses(Class1, Class2),
    is_current(Class1),
    is_current(Class2),
    not(dynFactNOTMergeClasses(Class1, Class2)),
    loginfoln('Concluding ~Q.', mergeClasses(Class1, Class2)),
    Out = mergeClasses(Class1, Class2).

/* Local Variables:   */
/* mode: prolog       */
/* fill-column:    95 */
/* comment-column: 0  */
/* End:               */
